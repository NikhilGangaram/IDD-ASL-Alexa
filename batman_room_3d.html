<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batman Smart Home - 3D Room</title>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(180deg, #0a0e27 0%, #1a1f3a 100%);
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* Status Panel */
        #status-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffd700;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            font-size: 14px;
            min-width: 250px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        #status-panel h3 {
            margin-top: 0;
            color: #ffd700;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .status-item {
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .status-item.active {
            background: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        /* Finger Count Display */
        #finger-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00ff00;
            font-size: 24px;
            text-align: center;
            min-width: 200px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        #finger-count {
            font-size: 48px;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }
        
        .no-hand {
            color: #666;
            font-size: 18px;
        }
        
        /* Dynamic Legend */
        #legend {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            max-width: 600px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        #legend h3 {
            margin-top: 0;
            color: #ffd700;
            text-align: center;
        }
        
        .legend-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .legend-item {
            padding: 8px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        .legend-item.highlight {
            background: rgba(255, 215, 0, 0.4);
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            animation: pulse 0.5s ease;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Mode Instructions */
        #mode-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #ffd700;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            font-size: 18px;
            text-align: center;
            max-width: 400px;
            display: none;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -45%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }
        
        #mode-instructions h2 {
            margin-top: 0;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .mode-list {
            text-align: left;
            margin: 20px 0;
            font-size: 16px;
        }
        
        .mode-list div {
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 5px;
        }
        
        /* Connection Status */
        #connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .connected {
            background: #00ff00;
            color: black;
        }
        
        .disconnected {
            background: #ff0000;
            color: white;
        }
    </style>
    <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Connection Status -->
    <div id="connection-status" class="disconnected">DISCONNECTED</div>
    
    <!-- Status Panel -->
    <div id="status-panel">
        <h3>System Status</h3>
        <div class="status-item">
            <strong>Mode Phase:</strong> <span id="mode-phase">SELECT_MODE</span>
        </div>
        <div class="status-item">
            <strong>Locked Mode:</strong> <span id="locked-mode">None</span>
        </div>
        <div class="status-item">
            <strong>Last Action:</strong> <span id="last-action">None</span>
        </div>
        <div class="status-item">
            <strong>Confidence:</strong> <span id="confidence">0%</span>
        </div>
    </div>
    
    <!-- Finger Count Display -->
    <div id="finger-display">
        <div>Fingers Detected</div>
        <div id="finger-count" class="no-hand">-</div>
        <div id="hand-status" class="no-hand">No hand detected</div>
    </div>
    
    <!-- Dynamic Legend -->
    <div id="legend">
        <h3>Controls</h3>
        <div id="legend-content"></div>
    </div>
    
    <!-- Mode Selection Instructions (shown when ready) -->
    <div id="mode-instructions">
        <h2>Ready for Input</h2>
        <p>Hold up 1-4 fingers to select mode:</p>
        <div class="mode-list">
            <div>üëÜ 1 Finger ‚Üí Temperature</div>
            <div>‚úåÔ∏è 2 Fingers ‚Üí Lights</div>
            <div>ü§ü 3 Fingers ‚Üí Blinds</div>
            <div>‚úã 4 Fingers ‚Üí Door</div>
        </div>
    </div>
    
    <script>
        // Socket.IO connection
        const socket = io();
        
        // State tracking
        let currentModePhase = 'SELECT_MODE';
        let currentLockedMode = null;
        let lastAction = null;
        let batmanModel = null;
        
        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffd700, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Batman model (simplified representation)
        const batmanGeometry = new THREE.ConeGeometry(1, 3, 8);
        const batmanMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x2c2c2c,
            emissive: 0x111111,
            specular: 0xffd700,
            shininess: 30
        });
        batmanModel = new THREE.Mesh(batmanGeometry, batmanMaterial);
        batmanModel.position.set(0, 0, 0);
        batmanModel.castShadow = true;
        scene.add(batmanModel);
        
        // Add bat symbol on the model
        const batSymbolGeometry = new THREE.PlaneGeometry(0.8, 0.4);
        const batSymbolMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffd700,
            side: THREE.DoubleSide
        });
        const batSymbol = new THREE.Mesh(batSymbolGeometry, batSymbolMaterial);
        batSymbol.position.set(0, 0.5, 1.01);
        batmanModel.add(batSymbol);
        
        // Floor
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x1a1a1a,
            side: THREE.DoubleSide
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -1.5;
        floor.receiveShadow = true;
        scene.add(floor);
        buildRoom();

        // Simple 3D room pieces that react to actions
        const roomState = {
            lightsOn: false,
            lightLevel: 0.6,
            blindsOpen: false,
            doorOpen: false,
            acSpeed: 0
        };
        
        let roomLight, bulbMesh, bulbMaterial, doorPivot, blindCover, sunPlane, windowLight, acFanGroup;
        
        function buildRoom() {
            const roomGroup = new THREE.Group();
            
            // Walls and ceiling
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x0f0f12, side: THREE.DoubleSide });
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(14, 6), wallMaterial);
            backWall.position.set(0, 1.5, -6);
            roomGroup.add(backWall);
            
            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(12, 6), wallMaterial);
            leftWall.position.set(-6, 1.5, 0);
            leftWall.rotation.y = Math.PI / 2;
            roomGroup.add(leftWall);
            
            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(12, 6), wallMaterial);
            rightWall.position.set(6, 1.5, 0);
            rightWall.rotation.y = -Math.PI / 2;
            roomGroup.add(rightWall);
            
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(14, 12), wallMaterial);
            ceiling.position.set(0, 3, 0);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.receiveShadow = true;
            roomGroup.add(ceiling);
            
            // Ceiling lamp + room light
            bulbMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x111111 });
            bulbMesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), bulbMaterial);
            bulbMesh.position.set(0, 2.7, 0);
            bulbMesh.castShadow = true;
            roomGroup.add(bulbMesh);
            
            roomLight = new THREE.PointLight(0xfff2cc, 1.2, 25);
            roomLight.position.copy(bulbMesh.position);
            roomLight.castShadow = true;
            scene.add(roomLight);
            
            // Window + blinds
            const windowGroup = new THREE.Group();
            windowGroup.position.set(6.01, 1.4, 0);
            windowGroup.rotation.y = -Math.PI / 2;
            
            sunPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(2.6, 1.6),
                new THREE.MeshBasicMaterial({ color: 0xffd37a, transparent: true, opacity: 0.8 })
            );
            sunPlane.position.z = -0.02;
            windowGroup.add(sunPlane);
            
            blindCover = new THREE.Mesh(
                new THREE.PlaneGeometry(2.6, 1.6),
                new THREE.MeshPhongMaterial({ color: 0x1c1c1c, transparent: true, opacity: 0.9, side: THREE.DoubleSide })
            );
            blindCover.position.z = 0.02;
            windowGroup.add(blindCover);
            
            const windowFrame = new THREE.Mesh(
                new THREE.PlaneGeometry(2.8, 1.8),
                new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide })
            );
            windowFrame.position.z = 0.05;
            windowGroup.add(windowFrame);
            
            roomGroup.add(windowGroup);
            
            // Door with hinge
            doorPivot = new THREE.Object3D();
            doorPivot.position.set(-6, -0.2, 1.5);
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 2.4, 0.12),
                new THREE.MeshPhongMaterial({ color: 0x3b2a1a, emissive: 0x0c0a08 })
            );
            door.position.set(0.6, 1.2, 0);
            door.castShadow = true;
            doorPivot.add(door);
            roomGroup.add(doorPivot);
            
            // AC unit with spinner
            const acBody = new THREE.Mesh(
                new THREE.BoxGeometry(1.6, 0.8, 0.4),
                new THREE.MeshPhongMaterial({ color: 0xbfc7ce, emissive: 0x0a0c10 })
            );
            acBody.position.set(2.5, 1.8, -5.6);
            acBody.castShadow = true;
            roomGroup.add(acBody);
            
            acFanGroup = new THREE.Group();
            acFanGroup.position.copy(acBody.position);
            const fanHub = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.08, 12), new THREE.MeshPhongMaterial({ color: 0x333333 }));
            fanHub.rotation.x = Math.PI / 2;
            acFanGroup.add(fanHub);
            const bladeMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
            for (let i = 0; i < 3; i++) {
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.08, 0.05), bladeMaterial);
                blade.position.x = 0.45;
                blade.rotation.z = (Math.PI * 2 / 3) * i;
                acFanGroup.add(blade);
            }
            roomGroup.add(acFanGroup);
            
            // Sunlight coming through window
            windowLight = new THREE.DirectionalLight(0xfff4d9, 0.2);
            windowLight.position.set(5, 3, 2);
            scene.add(windowLight);
            
            scene.add(roomGroup);
            updateRoomVisuals();
        }
        
        function updateRoomVisuals() {
            if (!roomLight || !bulbMaterial || !blindCover || !sunPlane || !windowLight || !doorPivot) return;
            
            const lightIntensity = roomState.lightsOn ? 0.6 + roomState.lightLevel : 0.15;
            roomLight.intensity = lightIntensity;
            ambientLight.intensity = roomState.lightsOn ? 0.6 : 0.2;
            bulbMaterial.emissive = new THREE.Color(roomState.lightsOn ? 0xffd700 : 0x111111);
            
            blindCover.scale.y = roomState.blindsOpen ? 0.05 : 1;
            blindCover.material.opacity = roomState.blindsOpen ? 0.2 : 0.9;
            sunPlane.material.opacity = roomState.blindsOpen ? 0.9 : 0.3;
            windowLight.intensity = roomState.blindsOpen ? 0.55 : 0.15;
            
            doorPivot.rotation.y = roomState.doorOpen ? -Math.PI / 2 : 0;
        }
        
        // Camera position
        camera.position.set(0, 2, 8);
        camera.lookAt(0, 0, 0);
        
        // Batman animations/states
        function setBatmanState(state) {
            if (!batmanModel) return;
            
            switch(state) {
                case 'READY':
                    // Idle/ready animation - gentle rotation
                    batmanModel.rotation.y = 0;
                    batmanMaterial.emissive = new THREE.Color(0x001100);
                    break;
                case 'POINT_LEFT':
                    batmanModel.rotation.y = Math.PI / 4;
                    batmanMaterial.emissive = new THREE.Color(0x110011);
                    break;
                case 'POINT_RIGHT':
                    batmanModel.rotation.y = -Math.PI / 4;
                    batmanMaterial.emissive = new THREE.Color(0x110011);
                    break;
                case 'OPEN_HAND':
                    batmanModel.scale.set(1.2, 1.2, 1.2);
                    batmanMaterial.emissive = new THREE.Color(0x002200);
                    setTimeout(() => batmanModel.scale.set(1, 1, 1), 500);
                    break;
                case 'FIST':
                    batmanModel.scale.set(0.8, 0.8, 0.8);
                    batmanMaterial.emissive = new THREE.Color(0x220000);
                    setTimeout(() => batmanModel.scale.set(1, 1, 1), 500);
                    break;
                default:
                    batmanMaterial.emissive = new THREE.Color(0x111111);
            }
        }
        
        // Update legend based on mode
        function updateLegend(modePhase, lockedMode) {
            const legendContent = document.getElementById('legend-content');
            
            if (modePhase === 'SELECT_MODE') {
                legendContent.innerHTML = `
                    <div class="legend-grid">
                        <div class="legend-item">üëÜ 1 Finger ‚Üí Temperature</div>
                        <div class="legend-item">‚úåÔ∏è 2 Fingers ‚Üí Lights</div>
                        <div class="legend-item">ü§ü 3 Fingers ‚Üí Blinds</div>
                        <div class="legend-item">‚úã 4 Fingers ‚Üí Door</div>
                    </div>
                `;
            } else if (modePhase === 'LOCKED_MODE' && lockedMode) {
                let actions = '';
                switch(lockedMode) {
                    case 'TEMPERATURE':
                        actions = `
                            <div class="legend-item" data-action="OPEN_HAND">‚úã Open Hand ‚Üí AC ON</div>
                            <div class="legend-item" data-action="FIST">‚úä Fist ‚Üí AC OFF</div>
                            <div class="legend-item" data-action="POINT_RIGHT">üëâ Point Right ‚Üí UP</div>
                            <div class="legend-item" data-action="POINT_LEFT">üëà Point Left ‚Üí DOWN</div>
                        `;
                        break;
                    case 'LIGHTS':
                        actions = `
                            <div class="legend-item" data-action="OPEN_HAND">‚úã Open Hand ‚Üí ON</div>
                            <div class="legend-item" data-action="FIST">‚úä Fist ‚Üí OFF</div>
                            <div class="legend-item" data-action="POINT_RIGHT">üëâ Point Right ‚Üí BRIGHT</div>
                            <div class="legend-item" data-action="POINT_LEFT">üëà Point Left ‚Üí DIM</div>
                        `;
                        break;
                    case 'BLINDS':
                        actions = `
                            <div class="legend-item" data-action="OPEN_HAND">‚úã Open Hand ‚Üí OPEN</div>
                            <div class="legend-item" data-action="FIST">‚úä Fist ‚Üí CLOSE</div>
                        `;
                        break;
                    case 'DOOR':
                        actions = `
                            <div class="legend-item" data-action="OPEN_HAND">‚úã Open Hand ‚Üí UNLOCK</div>
                            <div class="legend-item" data-action="FIST">‚úä Fist ‚Üí LOCK</div>
                        `;
                        break;
                }
                legendContent.innerHTML = `<div class="legend-grid">${actions}</div>`;
            }
        }
        
        // Highlight action in legend
        function highlightAction(action) {
            const items = document.querySelectorAll('.legend-item');
            items.forEach(item => {
                if (item.dataset.action === action) {
                    item.classList.add('highlight');
                    setTimeout(() => item.classList.remove('highlight'), 1000);
                }
            });
        }
        
        function applyAction(mode, gesture) {
            if (!mode || !gesture) return;
            
            const clamp = (val, min, max) => Math.min(max, Math.max(min, val));
            
            switch(mode) {
                case 'LIGHTS':
                    if (gesture === 'OPEN_HAND') {
                        roomState.lightsOn = true;
                        roomState.lightLevel = 0.9;
                    } else if (gesture === 'FIST') {
                        roomState.lightsOn = false;
                    } else if (gesture === 'POINT_RIGHT') {
                        roomState.lightsOn = true;
                        roomState.lightLevel = clamp(roomState.lightLevel + 0.3, 0.3, 1.5);
                    } else if (gesture === 'POINT_LEFT') {
                        roomState.lightsOn = true;
                        roomState.lightLevel = clamp(roomState.lightLevel - 0.3, 0.2, 1.5);
                    }
                    break;
                case 'BLINDS':
                    if (gesture === 'OPEN_HAND') roomState.blindsOpen = true;
                    if (gesture === 'FIST') roomState.blindsOpen = false;
                    break;
                case 'DOOR':
                    if (gesture === 'OPEN_HAND') roomState.doorOpen = true;
                    if (gesture === 'FIST') roomState.doorOpen = false;
                    break;
                case 'TEMPERATURE':
                    if (gesture === 'OPEN_HAND') roomState.acSpeed = Math.max(roomState.acSpeed, 1.2);
                    if (gesture === 'FIST') roomState.acSpeed = 0;
                    if (gesture === 'POINT_RIGHT') roomState.acSpeed = clamp(roomState.acSpeed + 0.6, 0, 4);
                    if (gesture === 'POINT_LEFT') roomState.acSpeed = clamp(roomState.acSpeed - 0.6, 0, 4);
                    break;
            }
            
            updateRoomVisuals();
        }
        
        // Socket.IO event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            document.getElementById('connection-status').className = 'connected';
            document.getElementById('connection-status').textContent = 'CONNECTED';
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            document.getElementById('connection-status').className = 'disconnected';
            document.getElementById('connection-status').textContent = 'DISCONNECTED';
        });
        
        socket.on('gesture_telemetry', (data) => {
            // Update mode phase
            currentModePhase = data.mode_phase || 'SELECT_MODE';
            currentLockedMode = data.locked_mode;
            
            document.getElementById('mode-phase').textContent = currentModePhase;
            document.getElementById('locked-mode').textContent = currentLockedMode || 'None';
            
            // Update finger count display
            if (data.finger_count !== null && data.finger_count !== undefined) {
                document.getElementById('finger-count').textContent = data.finger_count;
                document.getElementById('finger-count').className = '';
                document.getElementById('hand-status').textContent = `Stable for ${data.confidence ? Math.round(data.confidence * 5) : 0}/5 frames`;
                document.getElementById('hand-status').className = '';
            } else {
                document.getElementById('finger-count').textContent = '-';
                document.getElementById('finger-count').className = 'no-hand';
                document.getElementById('hand-status').textContent = 'No hand detected';
                document.getElementById('hand-status').className = 'no-hand';
            }
            
            // Update confidence
            const confidencePercent = Math.round((data.confidence || 0) * 100);
            document.getElementById('confidence').textContent = `${confidencePercent}%`;
            
            // Update action gesture
            if (data.action_gesture && currentModePhase === 'LOCKED_MODE') {
                lastAction = data.action_gesture;
                document.getElementById('last-action').textContent = data.action_gesture;
                setBatmanState(data.action_gesture);
                highlightAction(data.action_gesture);
                applyAction(currentLockedMode, data.action_gesture);
            }
            
            // Show/hide mode instructions
            const instructions = document.getElementById('mode-instructions');
            if (currentModePhase === 'SELECT_MODE') {
                instructions.style.display = 'block';
                setBatmanState('READY');
            } else {
                instructions.style.display = 'none';
            }
            
            // Update legend
            updateLegend(currentModePhase, currentLockedMode);
        });
        
        socket.on('gesture_command', (data) => {
            console.log('Gesture command:', data);
            // Visual feedback for commands
            const statusItems = document.querySelectorAll('.status-item');
            statusItems.forEach(item => {
                item.classList.add('active');
                setTimeout(() => item.classList.remove('active'), 500);
            });
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Idle animation for Batman model
            if (batmanModel && currentModePhase === 'SELECT_MODE') {
                batmanModel.rotation.y += 0.005;
            }
            
            // AC fan spin when on
            if (acFanGroup && roomState.acSpeed > 0) {
                acFanGroup.rotation.z += 0.1 * roomState.acSpeed;
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start animation
        animate();
        
        // Initialize
        setBatmanState('READY');
        updateLegend('SELECT_MODE', null);
    </script>
</body>
</html>