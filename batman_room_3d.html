<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batman Cave - 3D Room Control</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        /* HUD Overlay */
        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(33, 33, 33, 0.95), rgba(10, 10, 10, 0.95));
            border: 2px solid #FFC107;
            border-radius: 15px;
            padding: 20px;
            min-width: 300px;
            box-shadow: 
                0 0 30px rgba(255, 193, 7, 0.3),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .hud-title {
            font-size: 1.2rem;
            font-weight: 900;
            color: #FFC107;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .status-grid {
            display: grid;
            gap: 10px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.5);
            border-left: 3px solid #FFC107;
            border-radius: 5px;
        }

        .status-label {
            color: #757575;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .status-value {
            color: #FFC107;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
        }

        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, rgba(33, 33, 33, 0.95), rgba(10, 10, 10, 0.95));
            border: 1px solid #FFC107;
            border-radius: 25px;
            padding: 10px 20px;
            z-index: 100;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #FF5252;
            box-shadow: 0 0 10px rgba(255, 82, 82, 0.5);
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #00E676;
            box-shadow: 0 0 10px rgba(0, 230, 118, 0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            color: #E0E0E0;
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Mode Display */
        .mode-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.2), rgba(255, 193, 7, 0.1));
            border: 2px solid #FFC107;
            border-radius: 10px;
            padding: 15px 30px;
            font-size: 1.5rem;
            font-weight: 900;
            color: #FFC107;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(255, 193, 7, 0.8);
            display: none;
            z-index: 200;
            animation: modeGlow 1s ease-in-out;
        }

        @keyframes modeGlow {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(33, 33, 33, 0.95);
            border: 1px solid #FFC107;
            border-radius: 10px;
            padding: 15px 25px;
            z-index: 100;
            color: #757575;
            text-align: center;
        }

        .instructions span {
            color: #FFC107;
            font-weight: 700;
        }

        /* Loading Screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-text {
            font-size: 1.5rem;
            color: #FFC107;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-text">INITIALIZING CAVE...</div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- HUD Status Panel -->
    <div class="hud">
        <div class="hud-title">Cave Systems</div>
        <div class="status-grid">
            <div class="status-item">
                <span class="status-label">Temperature</span>
                <span class="status-value" id="tempStatus">72Â°F</span>
            </div>
            <div class="status-item">
                <span class="status-label">Lights</span>
                <span class="status-value" id="lightsStatus">OFF</span>
            </div>
            <div class="status-item">
                <span class="status-label">Blinds</span>
                <span class="status-value" id="blindsStatus">OPEN</span>
            </div>
            <div class="status-item">
                <span class="status-label">Security</span>
                <span class="status-value" id="doorStatus">LOCKED</span>
            </div>
        </div>
    </div>

    <!-- Connection Status -->
    <div class="connection-status">
        <div class="status-dot" id="connectionDot"></div>
        <span class="status-text" id="connectionText">OFFLINE</span>
    </div>

    <!-- Mode Display -->
    <div class="mode-display" id="modeDisplay">MODE: NONE</div>

    <!-- Instructions -->
    <div class="instructions">
        <span>Mouse:</span> Rotate View | <span>Scroll:</span> Zoom | <span>Gestures:</span> Control Room
    </div>

    <script>
        // Initialize Socket.IO
        const socket = io();
        
        // Three.js Setup
        let scene, camera, renderer;
        let room, lights, door, blinds, tempDisplay;
        let ambientLight, mainLight, spotLight;
        let mouseX = 0, mouseY = 0;
        
        // Room State
        const roomState = {
            temperature: 72,
            lights: 'OFF',
            blinds: 'OPEN',
            door: 'LOCKED'
        };

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 50);
            
            // Camera Setup
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            
            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Lighting Setup
            setupLighting();
            
            // Create Room
            createRoom();
            
            // Create Furniture and Details
            createFurniture();
            
            // Controls
            setupControls();
            
            // Start Animation
            animate();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1500);
        }

        function setupLighting() {
            // Ambient Light (very dim for cave atmosphere)
            ambientLight = new THREE.AmbientLight(0x0a0a0a);
            scene.add(ambientLight);
            
            // Main Room Light (controllable)
            mainLight = new THREE.PointLight(0xFFC107, 0, 20);
            mainLight.position.set(0, 8, 0);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            // Spot Light for dramatic effect
            spotLight = new THREE.SpotLight(0xFFC107, 0.3);
            spotLight.position.set(-8, 10, 8);
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            spotLight.target.position.set(0, 0, 0);
            scene.add(spotLight);
            scene.add(spotLight.target);
            
            // Computer screens glow
            const screenLight1 = new THREE.PointLight(0x00E676, 0.5, 5);
            screenLight1.position.set(5, 2, -7);
            scene.add(screenLight1);
            
            const screenLight2 = new THREE.PointLight(0x2196F3, 0.5, 5);
            screenLight2.position.set(-5, 2, -7);
            scene.add(screenLight2);
        }

        function createRoom() {
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0a0a0a,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Add floor pattern
            const gridHelper = new THREE.GridHelper(20, 20, 0x222222, 0x111111);
            scene.add(gridHelper);
            
            // Walls
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a1a,
                side: THREE.DoubleSide
            });
            
            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 12),
                wallMaterial
            );
            backWall.position.z = -10;
            backWall.receiveShadow = true;
            scene.add(backWall);
            
            // Left wall
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 12),
                wallMaterial
            );
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.x = -10;
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            
            // Right wall with window
            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 12),
                wallMaterial
            );
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.x = 10;
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            
            // Ceiling
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshPhongMaterial({ color: 0x0a0a0a })
            );
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 12;
            scene.add(ceiling);
            
            // Create Door
            createDoor();
            
            // Create Window with Blinds
            createWindow();
            
            // Temperature Display (floating hologram)
            createTemperatureDisplay();
        }

        function createDoor() {
            const doorGroup = new THREE.Group();
            
            // Door frame
            const frameGeometry = new THREE.BoxGeometry(3.2, 7.2, 0.2);
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(0, 3.6, -9.9);
            doorGroup.add(frame);
            
            // Door panel
            const doorGeometry = new THREE.BoxGeometry(3, 7, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2a2a2a,
                metalness: 0.5,
                roughness: 0.7
            });
            door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(-1.5, 0, 0);
            door.castShadow = true;
            
            // Door handle
            const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
            const handleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFC107,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xFFC107,
                emissiveIntensity: 0.2
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.rotation.z = Math.PI / 2;
            handle.position.set(1.2, 0, 0.1);
            door.add(handle);
            
            // Lock indicator
            const lockGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const lockMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF5252,
                emissive: 0xFF5252,
                emissiveIntensity: 0.5
            });
            const lock = new THREE.Mesh(lockGeometry, lockMaterial);
            lock.position.set(1.2, 0.5, 0.1);
            lock.name = 'lock';
            door.add(lock);
            
            // Position door in doorframe
            const doorPivot = new THREE.Group();
            doorPivot.add(door);
            doorPivot.position.set(-1.5, 3.5, -9.85);
            doorGroup.add(doorPivot);
            door.userData = { pivot: doorPivot, locked: true };
            
            scene.add(doorGroup);
        }

        function createWindow() {
            // Window frame
            const windowFrame = new THREE.Group();
            
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            // Frame pieces
            const frameTop = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.2, 0.2),
                frameMaterial
            );
            frameTop.position.set(5, 7, 0);
            
            const frameBottom = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.2, 0.2),
                frameMaterial
            );
            frameBottom.position.set(5, 3, 0);
            
            const frameLeft = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 4, 0.2),
                frameMaterial
            );
            frameLeft.position.set(3, 5, 0);
            
            const frameRight = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 4, 0.2),
                frameMaterial
            );
            frameRight.position.set(7, 5, 0);
            
            windowFrame.add(frameTop, frameBottom, frameLeft, frameRight);
            windowFrame.position.x = 9.9;
            scene.add(windowFrame);
            
            // Window glass
            const glassGeometry = new THREE.PlaneGeometry(3.8, 3.8);
            const glassMaterial = new THREE.MeshPhongMaterial({
                color: 0x000033,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glass = new THREE.Mesh(glassGeometry, glassMaterial);
            glass.position.set(5, 5, 0);
            glass.rotation.y = -Math.PI / 2;
            glass.position.x = 9.85;
            scene.add(glass);
            
            // Blinds
            blinds = new THREE.Group();
            for (let i = 0; i < 10; i++) {
                const slat = new THREE.Mesh(
                    new THREE.BoxGeometry(3.6, 0.35, 0.05),
                    new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
                );
                slat.position.set(5, 6.8 - i * 0.4, 0);
                slat.position.x = 9.8;
                slat.rotation.y = -Math.PI / 2;
                blinds.add(slat);
            }
            blinds.visible = false;
            scene.add(blinds);
        }

        function createTemperatureDisplay() {
            // Floating holographic temperature display
            const displayGroup = new THREE.Group();
            
            // Hologram base
            const baseGeometry = new THREE.CylinderGeometry(1, 1, 0.1, 32);
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFC107,
                emissive: 0xFFC107,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.5
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            displayGroup.add(base);
            
            // Temperature ring
            const ringGeometry = new THREE.TorusGeometry(0.8, 0.05, 16, 100);
            const ringMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFC107,
                emissive: 0xFFC107,
                emissiveIntensity: 0.5
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.y = 0.5;
            displayGroup.add(ring);
            
            // Inner display sphere
            const sphereGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFC107,
                emissive: 0xFFC107,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.8
            });
            tempDisplay = new THREE.Mesh(sphereGeometry, sphereMaterial);
            tempDisplay.position.y = 0.5;
            displayGroup.add(tempDisplay);
            
            displayGroup.position.set(-5, 3, 5);
            displayGroup.name = 'tempDisplay';
            scene.add(displayGroup);
        }

        function createFurniture() {
            // Desk
            const deskGroup = new THREE.Group();
            
            // Desk top
            const deskTop = new THREE.Mesh(
                new THREE.BoxGeometry(6, 0.2, 2),
                new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
            );
            deskTop.position.y = 3;
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            
            // Desk legs
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x0a0a0a });
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
            
            const legs = [];
            for (let x = -2.5; x <= 2.5; x += 5) {
                for (let z = -0.8; z <= 0.8; z += 1.6) {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 1.5, z);
                    legs.push(leg);
                }
            }
            
            deskGroup.add(deskTop, ...legs);
            deskGroup.position.set(0, 0, -7);
            scene.add(deskGroup);
            
            // Monitors on desk
            const monitor1 = createMonitor();
            monitor1.position.set(-2, 3.2, -7);
            scene.add(monitor1);
            
            const monitor2 = createMonitor();
            monitor2.position.set(2, 3.2, -7);
            scene.add(monitor2);
            
            // Chair
            const chair = createChair();
            chair.position.set(0, 0, -3);
            scene.add(chair);
            
            // Side table with lamp
            const tableGroup = new THREE.Group();
            
            const tableTop = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 1, 0.1, 32),
                new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
            );
            tableTop.position.y = 2;
            
            const tableLeg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 2, 16),
                new THREE.MeshPhongMaterial({ color: 0x0a0a0a })
            );
            tableLeg.position.y = 1;
            
            tableGroup.add(tableTop, tableLeg);
            tableGroup.position.set(7, 0, 5);
            scene.add(tableGroup);
        }

        function createMonitor() {
            const monitorGroup = new THREE.Group();
            
            // Screen
            const screen = new THREE.Mesh(
                new THREE.BoxGeometry(3, 2, 0.1),
                new THREE.MeshPhongMaterial({ 
                    color: 0x000000,
                    emissive: 0x00E676,
                    emissiveIntensity: 0.1
                })
            );
            
            // Stand
            const stand = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16),
                new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
            );
            stand.position.y = -1.1;
            
            monitorGroup.add(screen, stand);
            return monitorGroup;
        }

        function createChair() {
            const chairGroup = new THREE.Group();
            
            // Seat
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 2),
                new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
            );
            seat.position.y = 2;
            
            // Back
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(2, 2, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
            );
            back.position.set(0, 3, -0.9);
            
            // Legs
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x0a0a0a });
            const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
            
            const legs = [];
            for (let x = -0.8; x <= 0.8; x += 1.6) {
                for (let z = -0.8; z <= 0.8; z += 1.6) {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 1, z);
                    legs.push(leg);
                }
            }
            
            chairGroup.add(seat, back, ...legs);
            return chairGroup;
        }

        function setupControls() {
            // Mouse movement
            document.addEventListener('mousemove', onMouseMove, false);
            
            // Scroll zoom
            document.addEventListener('wheel', onMouseWheel, false);
            
            // Window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function onMouseMove(event) {
            mouseX = (event.clientX - window.innerWidth / 2) / 100;
            mouseY = (event.clientY - window.innerHeight / 2) / 100;
        }

        function onMouseWheel(event) {
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(10, Math.min(25, camera.position.z));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Camera smooth follow mouse
            camera.position.x += (mouseX * 2 - camera.position.x) * 0.05;
            camera.position.y += (-mouseY * 2 + 5 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);
            
            // Animate temperature display
            if (tempDisplay) {
                tempDisplay.rotation.y += 0.01;
                const tempGroup = scene.getObjectByName('tempDisplay');
                if (tempGroup) {
                    tempGroup.rotation.y += 0.005;
                    tempGroup.position.y = 3 + Math.sin(Date.now() * 0.001) * 0.1;
                }
            }
            
            renderer.render(scene, camera);
        }

        // MQTT/WebSocket Handlers
        socket.on('connect', function() {
            console.log('Connected to server');
            updateConnectionStatus(true);
        });

        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            updateConnectionStatus(false);
        });

        socket.on('mqtt_status', function(data) {
            updateConnectionStatus(data.connected);
        });

        socket.on('gesture_command', function(data) {
            handleGestureCommand(data);
        });

        socket.on('current_mode', function(data) {
            showMode(data.mode);
        });

        socket.on('gesture_states', function(states) {
            if (states.TEMPERATURE) updateTemperature(states.TEMPERATURE);
            if (states.LIGHTS) updateLights(states.LIGHTS);
            if (states.BLINDS) updateBlinds(states.BLINDS);
            if (states.DOOR) updateDoor(states.DOOR);
        });

        function handleGestureCommand(data) {
            const { category, action, value } = data;
            
            switch(category.toUpperCase()) {
                case 'TEMPERATURE':
                    updateTemperature(value);
                    break;
                case 'LIGHTS':
                    updateLights(value);
                    break;
                case 'BLINDS':
                    updateBlinds(value);
                    break;
                case 'DOOR':
                    updateDoor(value);
                    break;
            }
        }

        function updateTemperature(value) {
            roomState.temperature = parseInt(value) || roomState.temperature;
            document.getElementById('tempStatus').textContent = value;
            
            // Update temperature display color
            if (tempDisplay) {
                let color;
                if (roomState.temperature >= 75) {
                    color = 0xFF5252; // Red for hot
                } else if (roomState.temperature <= 68) {
                    color = 0x00E676; // Green for cold
                } else {
                    color = 0xFFC107; // Yellow for normal
                }
                
                tempDisplay.material.color.setHex(color);
                tempDisplay.material.emissive.setHex(color);
            }
        }

        function updateLights(value) {
            roomState.lights = value.toUpperCase();
            document.getElementById('lightsStatus').textContent = roomState.lights;
            
            // Update lighting
            let intensity = 0;
            if (roomState.lights === 'ON' || roomState.lights === 'BRIGHT') {
                intensity = 1.5;
            } else if (roomState.lights === 'DIM') {
                intensity = 0.5;
            }
            
            // Animate light changes
            const targetIntensity = intensity;
            const animateLights = () => {
                const delta = (targetIntensity - mainLight.intensity) * 0.1;
                mainLight.intensity += delta;
                
                if (Math.abs(targetIntensity - mainLight.intensity) > 0.01) {
                    requestAnimationFrame(animateLights);
                }
            };
            animateLights();
        }

        function updateBlinds(value) {
            roomState.blinds = value.toUpperCase();
            document.getElementById('blindsStatus').textContent = roomState.blinds;
            
            // Update blinds visibility
            if (blinds) {
                if (roomState.blinds === 'CLOSED') {
                    blinds.visible = true;
                    blinds.children.forEach((slat, index) => {
                        setTimeout(() => {
                            slat.visible = true;
                        }, index * 50);
                    });
                } else if (roomState.blinds === 'PARTIAL' || roomState.blinds === 'HALF') {
                    blinds.visible = true;
                    blinds.children.forEach((slat, index) => {
                        slat.visible = index < 5;
                    });
                } else {
                    blinds.children.forEach((slat, index) => {
                        setTimeout(() => {
                            slat.visible = false;
                        }, index * 50);
                    });
                    setTimeout(() => {
                        blinds.visible = false;
                    }, 500);
                }
            }
        }

        function updateDoor(value) {
            roomState.door = value.toUpperCase();
            document.getElementById('doorStatus').textContent = roomState.door;
            
            // Update door animation
            if (door && door.userData.pivot) {
                const isOpen = roomState.door === 'UNLOCKED' || roomState.door === 'OPEN';
                const targetRotation = isOpen ? -Math.PI / 3 : 0;
                
                const animateDoor = () => {
                    const delta = (targetRotation - door.userData.pivot.rotation.y) * 0.1;
                    door.userData.pivot.rotation.y += delta;
                    
                    if (Math.abs(targetRotation - door.userData.pivot.rotation.y) > 0.01) {
                        requestAnimationFrame(animateDoor);
                    }
                };
                animateDoor();
                
                // Update lock color
                const lock = door.getObjectByName('lock');
                if (lock) {
                    const lockColor = isOpen ? 0x00E676 : 0xFF5252;
                    lock.material.color.setHex(lockColor);
                    lock.material.emissive.setHex(lockColor);
                }
            }
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            
            if (connected) {
                dot.classList.add('connected');
                text.textContent = 'CONNECTED';
            } else {
                dot.classList.remove('connected');
                text.textContent = 'OFFLINE';
            }
        }

        function showMode(mode) {
            const display = document.getElementById('modeDisplay');
            if (mode && mode !== 'None') {
                display.textContent = `MODE: ${mode.toUpperCase()}`;
                display.style.display = 'block';
                
                setTimeout(() => {
                    display.style.display = 'none';
                }, 2500);
            }
        }

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
